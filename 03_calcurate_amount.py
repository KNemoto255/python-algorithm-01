"""
計算コストや実行時間を考慮したアルゴリズム
「良い」アルゴリズムとはデータ量に対する計算コスト・実行時間が少ないアルゴリズムを指す。
例えばフィボナッチ数の計算などではメモ化を活用した方が良いアルゴリズムとなる。

環境・言語に依存せずにアルゴリズムを評価する指標として、「計算量」が用いられる。

時間計算量 - 処理にかかる時間
空間計算量 - 処理に要する記憶容量

メモ化を活用すると時間計算量が減る代わりに、処理に要する空間計算量が増える場合もある。

入力量にたいする計算量の増分を自然対数・指数などで表現する記法を、オーダー記法という。
複数のアルゴリズムを検討する際、どれが効率が良いかを大雑把に検定できる

オーダーの比較

O(1) - リスト・コレクション等へのアクセス
O(logn) - 二分探索
O(n) - 線形探索
O(n*logn) - マージソート、ヒープソート
O(n^2) - 選択ソート、挿入ソート、バブルソート、シェルソート
O(n^3) - 行列の掛け算
O(2^n) - ナップサック問題
O(n!) - 巡回セールスマン問題

計算量に関してより詳細に学びたい場合は、チューリングマシン等の情報科学に関して学ぶ

アルゴリズムの計算量を考える際は、最も処理に時間がかかるデータの処理＝最悪計算量,
もしくは最悪計算量になるケースが少ない場合は平均計算量を基準とする。

データ構造と計算量
データを複数処理する場合、多くの場合リストやコレクションを使う。
実装するアルゴリズムによっては、1つの要素に次のデータのアドレスを合わせた連結リストを使った方が良いアルゴリズムにできる場合がある。
リストに要素を追加・削除すると必要な計算量はO(n)となるが、連結リストならO(1)で済む。
一方、読み取り自体は連結リストの方が計算量が多くなる。

巡回セールスマン問題のような最初はn通り、次はn-1通り...のような問題の計算量はO(n!)となる。
このような多項式時間で解けない問題の一部は、P=/NP予想で著名な「NP困難問題」に属する。
クラスP - 多項式時間で「判定」可能な問題
クラスNP - 多項式時間で「検証」可能な問題
NP困難 - 多項式時間で判定できない問題

P=NPであることが証明されれば、ハミルトン閉路問題・RSA暗号の作成など、O(n!) の計算量を要する
アルゴリズムが原理的にはO(n) の計算量で解けるより良いアルゴリズムに代替できる可能性がある。
一方、NP困難な問題は多項式時間での判定は出来ない。
"""

"""
プログラミングにおける探索
リストに特定の値があるか、最初から最後までしらみつぶしに探索する → 線形探索
O(n)
"""

data = [50,30,90,10,20,70,60,40,80]
found = False
data_look =40

print("探索するデータ: "+ str(data_look))

for i in range(len(data)):
    if data[i] == data_look:

        print("発見したデータのインデックス: "+ str(i))
        found = True
        break

if not found:
    print("データが見つかりませんでした。")

"""
より効率的な探索
探索範囲を半分に分け、入っていない方は処理しない → 二分探索
O(log(n))
二分探索を使うと計算量が対数に比例するので、かなり計算効率がよくなる。
特に計算量が線形探索の20%以下となる、10個以上のリストを探索する場合で効果的

二分探索を使えるケースは、リストが昇順・降順で並んでいる場合に限られる
"""
def binary_search(data,value):
    #左端・右端のインデックス
    left = 0
    right = len(data)-1

    #探索範囲の中央
    while left <= right:
        mid = (left + right)//2

    #中央の値と一致→ 位置を返し、探索範囲を切り替える
    if data[mid] == Value:
        return mid
    elif data[mid] < Value:
        left = mid + 1
    else:
        right = mid -1

    #見つからなかった場合は値を返さない
    return -1

data = [10,20,30,40,50,60,70,80,90]
result = binary_search(data, 90)

print("発見したデータのインデックス: "+ str(result))


"""
木構造での探索
深さ優先探索 - 深さを高めることを優先してデータを探索する・
オセロや将棋、囲碁などの対戦型ゲームの実装に用いる
幅優先探索 - 探索開始箇所から近い順に探索することを優先する
"""
#幅優先対策を実装する
tree = [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[],[],[],[],[],[],[],[]]
data = [0]

while len(data) > 0:
    pos = data.pop(0)
    print(pos, end = " ")
    for i in tree[pos]:
        data.append(i)

#深さ優先対策(行きがけ順)
tree = [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[],[],[],[],[],[],[],[]]
data = [0]

#再帰的に関数を呼び出すことで、一番下の階層を参照する
def search(pos):
    print(pos, end =" ")
    for i in tree[pos]:
        search(i)

search(0)
